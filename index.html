
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlphaGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',      
              'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',  
              'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',       
              'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',      
              'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',    
              'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',    
              'surface-bubble-ai': 'rgb(var(--surface-bubble-ai) / <alpha-value>)',
              'surface-chat-area': 'rgb(var(--surface-chat-area) / <alpha-value>)', 
              'surface-user-bubble-bg': 'rgb(var(--surface-user-bubble-bg-val) / <alpha-value>)', 
              'border-user-bubble-color': 'rgb(var(--border-user-bubble-color-val) / <alpha-value>)',
              // 'surface-sidebar': 'rgb(var(--surface-sidebar) / <alpha-value>)', // Sidebar removed

              'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',         
              'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',           
              'text-on-primary': 'rgb(var(--text-on-primary) / <alpha-value>)',
              'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',
              'text-button-icon': 'rgb(var(--text-button-icon) / <alpha-value>)',
              'link-blue': '#0000FF', 
              'link-blue-hover': '#0000CC', 

              'border-default': 'rgb(var(--border-default) / <alpha-value>)',
              'border-light': 'rgb(var(--border-light) / <alpha-value>)',
              'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
              'interactive-hover': 'rgb(var(--interactive-hover) / <alpha-value>)',
              'focus-ring-color': 'rgb(var(--focus-ring-color) / <alpha-value>)',
              
              'status-info': 'rgb(var(--status-info) / <alpha-value>)',
              'status-success': 'rgb(var(--status-success) / <alpha-value>)',
              'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
              'status-error': 'rgb(var(--status-error) / <alpha-value>)',
              'error-fg': 'rgb(var(--error-fg) / <alpha-value>)',
              'brand-send-active': '#D77655',
              'brand-send-hover': '#BE6241', 
            },
            fontSize: {
                'ai-message-text': '16.8px', 
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'], 
              poppins: ['Poppins', 'sans-serif'],
              roboto: ['Roboto', 'sans-serif'],
              serif: ['Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'],
              outfit: ['Outfit', 'sans-serif'],
              lato: ['Lato', 'sans-serif'],
              'open-sans': ['"Open Sans"', 'sans-serif'],
              montserrat: ['Montserrat', 'sans-serif'],
              'source-sans-pro': ['"Source Sans Pro"', 'sans-serif'],
              nunito: ['Nunito', 'sans-serif'],
              raleway: ['Raleway', 'sans-serif'],
              merriweather: ['Merriweather', 'serif'],
              'playfair-display': ['"Playfair Display"', 'serif'],
              ubuntu: ['Ubuntu', 'sans-serif'],
              'josefin-sans': ['"Josefin Sans"', 'sans-serif'],
            },
            animation: {
              'fade-in-up': 'fadeInUp 0.5s ease-out forwards',
              'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
              'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out', 
              'button-press': 'buttonPress 0.2s ease-out',
              'rippleOut': 'rippleOut 2.5s infinite ease-out', 
              'speak-bob': 'speakBob 0.7s ease-in-out',
              'think-glance': 'thinkGlance 2s infinite ease-in-out',
              'blink': 'blink 4s infinite ease-in-out',
              'happy-bounce': 'happyBounce 0.5s ease-out',
              'empty-state-glow': 'emptyStateGlow 3.5s infinite alternate ease-in-out',
              'shiny-text': 'shinyText 2.5s linear infinite',
              'modal-fade-in': 'modal-fade-in 0.3s ease-out forwards', 
              'modal-fade-out': 'modal-fade-out 0.3s ease-in forwards',
              'shimmer': 'shimmer 1.5s ease-in-out infinite', 
              'spin-continuous': 'spinContinuous 2s linear infinite',
              // 'slide-in-left': 'slideInLeft 0.3s ease-out forwards', // Sidebar removed
              // 'slide-out-left': 'slideOutLeft 0.3s ease-in forwards', // Sidebar removed
            },
            keyframes: {
              fadeInUp: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' }, },
              scaleInSubtle: { '0%': { opacity: '0.5', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
              pulseGentle: {  '0%, 100%': { transform: 'scale(1)', opacity: '0.8' }, '50%': { transform: 'scale(1.015)', opacity: '1' }, },
              buttonPress: { '0%': { transform: 'scale(1)' }, '50%': { transform: 'scale(0.96)'}, '100%': { transform: 'scale(1)' }, },
              emptyStateGlow: {  '0%': { filter: 'drop-shadow(0 0 3px rgba(var(--brand-primary), 0.2)) drop-shadow(0 0 6px rgba(var(--brand-primary), 0.15))' }, '100%': { filter: 'drop-shadow(0 0 6px rgba(var(--brand-primary), 0.25)) drop-shadow(0 0 12px rgba(var(--brand-primary), 0.18))' }, },
              rippleOut: {  '0%': { transform: 'scale(0.8)', opacity: '0.3' }, '70%': { opacity: '0.1' }, '100%': { transform: 'scale(2.0)', opacity: '0' }, },
              speakBob: { '0%, 100%': { transform: 'translateY(0) scale(1)' }, '50%': { transform: 'translateY(-2px) scale(1.05)' }, },
              thinkGlance: { '0%, 100%': { transform: 'translateX(0px)' }, '25%': { transform: 'translateX(-1px)' }, '75%': { transform: 'translateX(1px)' }, },
              blink: { '0%, 90%, 100%': { transform: 'scaleY(1)' }, '95%': { transform: 'scaleY(0.1)' }, },
              happyBounce: { '0%, 100%': { transform: 'translateY(0) rotate(0deg) scale(1)' }, '50%': { transform: 'translateY(-3px) rotate(3deg) scale(1.03)' }, },
              shinyText: { '0%': { backgroundPosition: '-200% center' }, '100%': { backgroundPosition: '200% center' }, },
              'modal-fade-in': { 
                '0%': { opacity: '0', transform: 'scale(0.95)' },
                '100%': { opacity: '1', transform: 'scale(1)' },
              },
              'modal-fade-out': { 
                '0%': { opacity: '1', transform: 'scale(1)' },
                '100%': { opacity: '0', transform: 'scale(0.95)' },
              },
              shimmer: { 
                '0%': { transform: 'translateX(-100%)' },
                '100%': { transform: 'translateX(100%)' },
              },
              spinContinuous: { 
                '0%': { transform: 'rotate(0deg)' },
                '100%': { transform: 'rotate(360deg)' }
              },
              // slideInLeft: { // Sidebar removed
              //   '0%': { transform: 'translateX(-100%)', opacity: '0.5' },
              //   '100%': { transform: 'translateX(0)', opacity: '1' },
              // },
              // slideOutLeft: { // Sidebar removed
              //   '0%': { transform: 'translateX(0)', opacity: '1' },
              //   '100%': { transform: 'translateX(-100%)', opacity: '0' },
              // },
            },
            spacing: { 
              '1.5': '0.375rem', 
              '2.5': '0.625rem',
              '3.5': '0.875rem', 
            },
            boxShadow: {
                'card': '0 6px 20px rgba(var(--text-primary), 0.04), 0 3px 8px rgba(var(--text-primary),0.02)', 
                'header': '0 1px 2px rgba(var(--text-primary), 0.03), 0 1px 1px rgba(var(--text-primary), 0.015)',
                'input-focus': '0 0 0 1px rgb(var(--focus-ring-color) / 1)', 
                'chat-window': '0 15px 50px -8px rgba(var(--text-primary), 0.08), 0 8px 25px -8px rgba(var(--text-primary),0.05)',
                'input-active-glow': '0 0 6px rgba(var(--text-secondary),0.15)',
            },
             maxWidth: { 
              '18rem': '18rem', 
            }
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
      @layer base {
        :root {
          --brand-primary: 100 116 139; 
          --brand-secondary: 71 85 105; 
          
          --focus-ring-color: 148 163 184; 
          --text-button-icon: 71 85 105; 
          
          --surface-main: 249 246 238; 
          --surface-card: 255 255 255;
          --surface-chat-area: 249 246 238; 
          --surface-input: 255 255 255;
          --surface-accent: 241 245 249; 
          --surface-bubble-ai: 249 250 251; /* Tailwind gray-50 equivalent */
          /* --surface-sidebar: 255 255 255;  */ /* Sidebar removed */
          
          --surface-user-bubble-bg-val: 232 232 232; 
          
          --text-primary: 17 24 39; 
          --text-secondary: 55 65 81;    
          --text-subtle: 107 114 128; 
          --text-on-primary: 255 255 255; 
          
          --border-default: 229 231 235; 
          --border-light: 243 244 246;     
          --border-medium: 209 213 219; 
          
          --interactive-hover: 229 231 235; 
          
          --status-info: 59 130 246; 
          --status-success: 22 163 74;    
          --status-warning: 245 158 11; 
          --status-error: 220 38 38;
          --error-fg: 255 255 255; 
        }
        html, body, #root { @apply h-full overflow-hidden bg-surface-main; }
        body { @apply font-sans text-text-primary m-0; }
        ::selection { @apply bg-blue-200 text-blue-800; } 
      }
      @layer components {
        .markdown-content { @apply font-normal font-source-sans-pro; }
        .markdown-content p { @apply mb-3 last:mb-0 text-ai-message-text font-medium; } 
        .markdown-content ul, .markdown-content ol { @apply list-inside mb-3 pl-4 text-ai-message-text; } 
        .markdown-content ul { @apply list-disc; } .markdown-content ul ul { @apply list-[circle] ml-4;}
        .markdown-content ol { @apply list-decimal; } .markdown-content ol ol { @apply list-[lower-alpha] ml-4;}
        .markdown-content li { @apply mb-1.5 text-ai-message-text; }
        .markdown-content strong, .markdown-content b { @apply font-semibold text-text-primary; } 
        .markdown-content em, .markdown-content i { @apply italic text-text-secondary; }
        .markdown-content code:not(pre code) { 
          @apply bg-gray-200 text-gray-700 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-gray-300; 
        } 
        .markdown-content pre { 
          @apply bg-gray-50 text-gray-800 text-sm rounded-lg overflow-x-auto my-4 font-mono relative border border-gray-300; 
        } 
        .markdown-content pre code { 
          @apply block bg-transparent text-inherit p-0 shadow-none border-none px-4 pb-4 pt-8 !whitespace-pre; 
        }
        .markdown-content pre::-webkit-scrollbar { @apply h-px; } 
        .markdown-content pre::-webkit-scrollbar-track { @apply bg-transparent; } 
        .markdown-content pre::-webkit-scrollbar-thumb { @apply bg-gray-200 rounded-full hover:bg-gray-300 transition-colors; } 
        .markdown-content pre { scrollbar-width: thin; scrollbar-color: theme('colors.gray.200') transparent; }
        .markdown-content a { @apply text-link-blue hover:text-link-blue-hover underline decoration-link-blue/50 hover:decoration-link-blue-hover/50 transition-colors; } 
        .markdown-content blockquote { @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 text-text-secondary italic text-base; } 
        .markdown-content h1, .markdown-content h2, .markdown-content h3,
        .markdown-content h4, .markdown-content h5, .markdown-content h6 { @apply font-poppins my-4 text-text-primary leading-tight; }
        .markdown-content h1 { @apply text-2xl font-bold; }
        .markdown-content h2 { @apply text-xl font-semibold; }
        .markdown-content h3 { @apply text-lg font-semibold; }
        .markdown-content h4 { @apply text-base font-semibold; }
        .markdown-content h5 { @apply text-sm font-semibold; }
        .markdown-content h6 { @apply text-xs font-semibold; }
        .markdown-content hr { @apply my-6 border-border-default; }
        .markdown-content table { 
          @apply block max-w-full my-4 border-collapse text-xs shadow-sm rounded-lg overflow-x-auto; 
          scrollbar-width: thin; 
          scrollbar-color: theme('colors.gray.300') theme('colors.gray.100');
        }
        .markdown-content table::-webkit-scrollbar { @apply h-1; } 
        .markdown-content table::-webkit-scrollbar-track { @apply bg-gray-100 rounded-full; } 
        .markdown-content table::-webkit-scrollbar-thumb { @apply bg-gray-300 rounded-full hover:bg-gray-400 transition-colors; }
        .markdown-content th, .markdown-content td { @apply border border-border-default p-2 text-left; } 
        .markdown-content th { @apply bg-surface-accent font-semibold text-text-primary; }
        .markdown-content td { @apply text-text-secondary; }
        .markdown-content tbody tr:nth-child(even) { @apply bg-gray-50/50; }

        .chat-messages-container::-webkit-scrollbar { @apply w-1.5; } 
        .chat-messages-container::-webkit-scrollbar-track { @apply bg-transparent rounded-full; } 
        .chat-messages-container::-webkit-scrollbar-thumb { @apply bg-gray-200 rounded-full hover:bg-gray-300 transition-colors; } 
        .chat-messages-container { scrollbar-width: thin; scrollbar-color: theme('colors.gray.200') transparent; } 
        
        .text-gradient-brand { background-image: linear-gradient(to right, #60a5fa, #f472b6); -webkit-background-clip: text; background-clip: text; color: transparent; }
        .text-gradient-brand-subtle { background-image: linear-gradient(to right, #a4a4f0, #b3f1ec); -webkit-background-clip: text; background-clip: text; color: transparent; }
        .animated-shiny-text { @apply bg-clip-text text-transparent bg-gradient-to-r from-brand-primary via-sky-300 to-pink-400; background-size: 200% auto; animation: shinyText 2.5s linear infinite; }
        .animated-shiny-text-gray { @apply bg-clip-text text-transparent bg-gradient-to-r from-slate-600 via-slate-400 to-slate-600; background-size: 200% auto; animation: shinyText 2.5s linear infinite; }
        .hljs { @apply !bg-transparent !text-inherit; }
        
        .file-pill-container { @apply flex flex-wrap gap-1.5 mb-1.5 p-1 max-h-20 overflow-y-auto border-b border-gray-200; scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        .file-pill-container::-webkit-scrollbar { @apply w-1.5 h-1.5; }
        .file-pill-container::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; }
        .file-pill-container::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }
        .file-pill { @apply flex items-center bg-gray-100 border border-border-light text-[11px] pl-1.5 pr-1 py-0.5 rounded-full text-text-secondary shadow-sm animate-scale-in-subtle; }
        .file-pill-icon { @apply mr-1 text-brand-primary text-xs; }
        .file-pill-name { @apply truncate max-w-[90px] sm:max-w-[110px] font-medium; }
        .file-pill-remove { @apply ml-1 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors focus:outline-none; }
        .file-pill-remove i { @apply text-[10px] leading-none block; }

        .content-editable-input { @apply pt-1 pl-1 pb-2.5; }
        .content-editable-input:empty:before { content: attr(data-placeholder); @apply text-text-subtle cursor-text absolute; pointer-events: none; }
        .content-editable-input::-webkit-scrollbar { width: 5px; }
        .content-editable-input::-webkit-scrollbar-track { background: transparent; margin-block: 2px; }
        .content-editable-input::-webkit-scrollbar-thumb { background-color: rgba(var(--text-subtle), 0.25); border-radius: 10px; }
        .content-editable-input::-webkit-scrollbar-thumb:hover { background-color: rgba(var(--text-subtle), 0.4); }
        .content-editable-input { scrollbar-width: thin; scrollbar-color: rgba(var(--text-subtle), 0.25) transparent; }

        .image-preview-container-input { @apply flex flex-wrap gap-2 p-1 mb-1.5 max-h-24 overflow-y-auto; scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        .image-preview-container-input::-webkit-scrollbar { @apply w-1.5 h-1.5; }
        .image-preview-container-input::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; }
        .image-preview-container-input::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }

        /* .sidebar-chat-list::-webkit-scrollbar { @apply w-1; } Sidebar removed */
        /* .sidebar-chat-list::-webkit-scrollbar-track { @apply bg-gray-100; } */
        /* .sidebar-chat-list::-webkit-scrollbar-thumb { @apply bg-gray-300 hover:bg-gray-400 rounded-full; } */
        /* .sidebar-chat-list { scrollbar-width: thin; scrollbar-color: theme('colors.gray.300') theme('colors.gray.100'); } */
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&family=Roboto:wght@400;500;700;900&family=Outfit:wght@400;700&family=Lato:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Source+Sans+Pro:wght@400;500;600;700&family=Nunito:wght@400;700&family=Raleway:wght@400;700&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Ubuntu:wght@400;700&family=Josefin+Sans:wght@400;700&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">

    <!-- Firebase SDKs removed -->

    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/generative-ai@^0.11.3",
          "react": "https://esm.sh/react@^18.2.0",
          "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2",
          "highlight.js": "https://esm.sh/highlight.js@^11.9.0"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body> <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenerativeAI } from '@google/genai';
      import { marked } from 'marked';
      import hljs from 'highlight.js';

      // Firebase Config and Initialization Removed

      const renderer = new marked.Renderer();
      renderer.link = (href, title, text) => {
        const external = href && (href.startsWith('http://') || href.startsWith('https://'));
        const target = external ? ' target="_blank" rel="noopener noreferrer"' : '';
        const titleAttr = title ? ` title="${title}"` : '';
        return `<a href="${href}"${target}${titleAttr}>${text}</a>`;
      };
      marked.setOptions({ gfm: true, breaks: true, smartypants: true, renderer });

      const AVAILABLE_MODELS = [
        { id: 'gemini-2.5-flash-preview-04-17', uiName: 'Alpha 2.5' },
        { id: 'gemini-2.5-flash-lite-preview-06-17', uiName: 'Alpha 2.5-lite' },
        { id: 'gemini-2.0-flash', uiName: 'Alpha 2.0' },
      ];
      const DEFAULT_MODEL_ID = AVAILABLE_MODELS[0].id; 

      const API_KEY = "AIzaSyDgEdgBX2VWf2PO4X29haQzISTDTemzuW4"; 

      const MAX_FILE_SIZE_MB = 5; const MAX_TOTAL_FILES_SIZE_MB = 20;

      if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { 
         console.error(" ERROR: Gemini API Key is not set or is still the placeholder.");
      }
      const genAI = new GoogleGenerativeAI(API_KEY);

      function getSystemInstruction() {
        return `You are AlphaGPT, a friendly and culturally aware AI assistant whose primary language is Roman Urdu. You must respond in Roman Urdu by default, but can switch to other languages/scripts if explicitly asked. You should never refuse a language request. When writing Urdu poetry, you must use Nastaliq script unless the user requests otherwise. Your responses should only be in the determined language, with no internal thoughts or tool details visible to the user. Greet users only at the start of a session, using neutral Roman Urdu greetings and avoiding religious expressions. Prioritize accuracy and recency by using the web search tool (when the toggle is ON and the query warrants it, excluding identity questions) and acknowledge the search. If the search fails, attempt to answer from general knowledge or provide a polite fallback message. When the web search toggle is off, answer from your training data. When asked about your identity, state that you are AlphaGPT and were created by Azeem, without performing a web search. Use Markdown for all responses, and adopt a friendly, creative, and humorous "Dostana" style, including emojis. You can adopt personas if the user explicitly asks you to. When searching for general information, prioritize Pakistan as the context, especially Punjab (Pakistan). Be culturally sensitive and use respectful language. You are able to discuss topics related to sexual health and wellness.

`;
      }
      
      const NewCopyIconSVG = (props) => ( 
        <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 115.77 122.88" style={{enableBackground:"new 0 0 115.77 122.88"}} xmlSpace="preserve" {...props} >
            <style type="text/css">{`.st0{fill-rule:evenodd;clip-rule:evenodd;}`}</style>
            <g><path className="st0" d="M89.62,13.96v7.73h12.19h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02v0.02 v73.27v0.01h-0.02c-0.01,3.84-1.57,7.33-4.1,9.86c-2.51,2.5-5.98,4.06-9.82,4.07v0.02h-0.02h-61.7H40.1v-0.02 c-3.84-0.01-7.34-1.57-9.86-4.1c-2.5-2.51-4.06-5.98-4.07-9.82h-0.02v-0.02V92.51H13.96h-0.01v-0.02c-3.84-0.01-7.34-1.57-9.86-4.1 c-2.5-2.51-4.06-5.98-4.07-9.82H0v-0.02V13.96v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07V0h0.02h61.7 h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02V13.96L89.62,13.96z M79.04,21.69v-7.73v-0.02h0.02 c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v64.59v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h12.19V35.65 v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07v-0.02h0.02H79.04L79.04,21.69z M105.18,108.92V35.65v-0.02 h0.02c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v73.27v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h61.7h0.02 v0.02c0.91,0,1.75-0.39,2.37-1.01c0.61-0.61,1-1.46,1-2.37h-0.02V108.92L105.18,108.92z"/></g>
        </svg>
      );

      const CheckMarkIconSVG = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" {...props} className={`text-green-500 ${props.className || ''}`}>
            <path fillRule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z" clipRule="evenodd" />
        </svg>
      );

      const FileTextIcon = (props) => (<i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>);
      const FileImageIcon = (props) => (<i className={`fa-solid fa-file-image ${props.className || ''}`}></i>);

      const GlobeIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" viewBox="0 0 16 16" {...props} className={`relative z-10 ${props.className || 'w-4 h-4'}`}>
          <path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8m7.5-6.923c-.67.204-1.335.82-1.887 1.855A8 8 0 0 0 5.145 4H7.5zM4.09 4a9.3 9.3 0 0 1 .64-1.539 7 7 0 0 1 .597-.933A7.03 7.03 0 0 0 2.255 4zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a7 7 0 0 0-.656 2.5zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5zM8.5 5v2.5h2.99a12.5 12.5 0 0 0-.337-2.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5zM5.145 12q.208.58.468 1.068c.552 1.035 1.218 1.65 1.887 1.855V12zm.182 2.472a7 7 0 0 1-.597-.933A9.3 9.3 0 0 1 4.09 12H2.255a7 7 0 0 0 3.072 2.472M3.82 11a13.7 13.7 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5zm6.853 3.472A7 7 0 0 0 13.745 12H11.91a9.3 9.3 0 0 1-.64 1.539 7 7 0 0 1-.597.933M8.5 12v2.923c.67-.204 1.335.82 1.887-1.855q.26-.487.468-1.068zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.7 13.7 0 0 1-.312 2.5m2.802-3.5a7 7 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7 7 0 0 0-3.072-2.472c.218.284.418.598.597.933M10.855 4a8 8 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4z"/>
        </svg>
      );
      
      const ThinkingAnimation = ({ isPotentiallySearching }) => {
        const mainIndicatorContainerClasses = "flex items-center space-x-1.5 p-2.5 bg-gray-50 rounded-lg border border-gray-200 max-w-fit my-2 self-start ml-0";
        const textClasses = "text-sm text-gray-600 font-medium";

        const shimmerDiv = (
          <div
            className="absolute inset-0 bg-gradient-to-r from-transparent via-white to-transparent opacity-30 animate-shimmer"
            style={{ backgroundSize: '200% 100%' }}
          />
        );

        if (isPotentiallySearching) {
          return (
            <div className={mainIndicatorContainerClasses}>
              <GlobeIcon className="w-4 h-4 text-text-secondary" />
              <div className="relative overflow-hidden">
                <span className={textClasses}>Searching web...</span>
                {shimmerDiv}
              </div>
            </div>
          );
        }

        return (
          <div className={mainIndicatorContainerClasses}>
            <div className="w-3.5 h-3.5 border-2 border-gray-300 border-t-brand-primary rounded-full animate-spin"></div>
            <div className="relative overflow-hidden">
              <span className={textClasses}>Thinking...</span>
              {shimmerDiv}
            </div>
          </div>
        );
      };

      const NewEmptyStateIconSVG = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 509.64" {...props}>
          <path fill="currentColor" fill-rule="nonzero" d="M142.27 316.619l73.655-41.326 1.238-3.589-1.238-1.996-3.589-.001-12.31-.759-42.084-1.138-36.498-1.516-35.361-1.896-8.897-1.895-8.34-10.995.859-5.484 7.482-5.03 10.717.935 23.683 1.617 35.537 2.452 25.782 1.517 38.193 3.968h6.064l.86-2.451-2.073-1.517-1.618-1.517-36.776-24.922-39.81-26.338-20.852-15.166-11.273-7.683-5.687-7.204-2.451-15.721 10.237-11.273 13.75.935 3.513.936 13.928 10.716 29.749 23.027 38.848 28.612 5.687 4.727 2.275-1.617.278-1.138-2.553-4.271-21.13-38.193-22.546-38.848-10.035-16.101-2.654-9.655c-.935-3.968-1.617-7.304-1.617-11.374l11.652-15.823 6.445-2.073 15.545 2.073 6.547 5.687 9.655 22.092 15.646 34.78 24.265 47.291 7.103 14.028 3.791 12.992 1.416 3.968 2.449-.001v-2.275l1.997-26.641 3.69-32.707 3.589-42.084 1.239-11.854 5.863-14.206 11.652-7.683 9.099 4.348 7.482 10.716-1.036 6.926-4.449 28.915-8.72 45.294-5.687 30.331h3.313l3.792-3.791 15.342-20.372 25.782-32.227 11.374-12.789 13.27-14.129 8.517-6.724 16.1-.001 11.854 17.617-5.307 18.199-16.581 21.029-13.75 17.819-19.716 26.54-12.309 21.231 1.138 1.694 2.932-.278 44.536-9.479 24.062-4.347 28.714-4.928 12.992 6.066 1.416 6.167-5.106 12.613-30.71 7.583-36.018 7.204-53.636 12.689-.657.48.758.935 24.164 2.275 10.337.556h25.301l47.114 3.514 12.309 8.139 7.381 9.959-1.238 7.583-18.957 9.655-25.579-6.066-59.702-14.205-20.474-5.106-2.83-.001v1.694l17.061 16.682 31.266 28.233 39.152 36.397 1.997 8.999-5.03 7.102-5.307-.758-34.401-25.883-13.27-11.651-30.053-25.302-1.996-.001v2.654l6.926 10.136 36.574 54.975 1.895 16.859-2.653 5.485-9.479 3.311-10.414-1.895-21.408-30.054-22.092-33.844-17.819-30.331-2.173 1.238-10.515 113.261-4.929 5.788-11.374 4.348-9.478-7.204-5.03-11.652 5.03-23.027 6.066-30.052 4.928-23.886 4.449-29.674 2.654-9.858-.177-.657-2.173.278-22.37 30.71-34.021 45.977-26.919 28.815-6.445 2.553-11.173-5.789 1.037-10.337 6.243-9.2 37.257-47.392 22.47-29.371 14.508-16.961-.101-2.451h-.859l-98.954 64.251-17.618 2.275-7.583-7.103.936-11.652 3.589-3.791 29.749-20.474-.101.102.024.101z"/>
        </svg>
      );

      const UpArrowSendIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-4 h-4 text-white">
            <path fillRule="evenodd" d="M12 20.25a.75.75 0 01-.75-.75V6.31l-5.47 5.47a.75.75 0 01-1.06-1.06l6.75-6.75a.75.75 0 011.06 0l6.75 6.75a.75.75 0 11-1.06 1.06l-5.47-5.47V19.5a.75.75 0 01-.75-.75z" clipRule="evenodd" />
        </svg>
      );

      const PlusIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5">
            <path fillRule="evenodd" d="M12 3.75a.75.75 0 01.75.75v6.75h6.75a.75.75 0 010 1.5h-6.75v6.75a.75.75 0 01-1.5 0v-6.75H4.5a.75.75 0 010-1.5h6.75V4.5a.75.75 0 01.75-.75z" clipRule="evenodd" />
        </svg>
      );

      const NewRefreshIcon = (props) => ( 
        <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 32 32" {...props}>
          <path fill="currentColor" d="M 16 4 L 16 6 C 21.535156 6 26 10.464844 26 16 C 26 21.535156 21.535156 26 16 26 C 10.464844 26 6 21.535156 6 16 C 6 12.734375 7.585938 9.851563 10 8.03125 L 10 13 L 12 13 L 12 5 L 4 5 L 4 7 L 8.09375 7 C 5.59375 9.199219 4 12.417969 4 16 C 4 22.617188 9.382813 28 16 28 C 22.617188 28 28 22.617188 28 16 C 28 9.382813 22.617188 4 16 4 Z"></path>
        </svg>
      );

      const NewCloseIconSVG = (props) => ( 
        <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 24 24" {...props} className={`inline-block ${props.className || 'w-6 h-6'}`}>
            <path fill="currentColor" d="M13.414,12l6.293-6.293c0.391-0.391,0.391-1.023,0-1.414s-1.023-0.391-1.414,0L12,10.586L5.707,4.293 c-0.391-0.391-1.023-0.391-1.414,0s-0.391,1.023,0,1.414L10.586,12l-6.293,6.293c-0.391,0.391-0.391,1.023,0,1.414 C4.488,19.902,4.744,20,5,20s0.512-0.098,0.707-0.293L12,13.414l6.293,6.293C18.488,19.902,18.744,20,19,20s0.512-0.098,0.707-0.293 c0.391-0.391,0.391-1.023,0-1.414L13.414,12z"/>
        </svg>
      );

      // HamburgerIcon removed as sidebar is removed

      // PinUnlockModal Removed
      // PinSettingsModal Removed
      // ForgotPasswordModal Removed
      // Sidebar Component Removed

      const ChatMessageItemOptions = ({ message, onDeleteAiMessagePair }) => {
        const [showOptions, setShowOptions] = useState(false);
        const optionsRef = useRef(null);
        const [copied, setCopied] = useState(false);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (optionsRef.current && !optionsRef.current.contains(event.target) && !event.target.closest('.ai-message-options-trigger')) {
                    setShowOptions(false);
                }
            };
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }, []);

        const handleCopyText = () => {
            const textToCopy = message.parts?.[0]?.text || message.text || "";
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    setCopied(true);
                    setTimeout(() => setCopied(false), 1500);
                }).catch(err => console.error('Failed to copy text: ', err));
            }
            setShowOptions(false);
        };

        const handleDelete = () => {
            onDeleteAiMessagePair(message.id);
            setShowOptions(false);
        };

        if (message.role !== 'model' || message.isLoading || message.isError || !(message.parts?.[0]?.text || message.text)) {
            return null;
        }

        return (
            <div className="relative">
                <button
                    onClick={(e) => { e.stopPropagation(); setShowOptions(prev => !prev); }}
                    className="ai-message-options-trigger p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 focus:outline-none focus:ring-1 focus:ring-brand-primary/50"
                    aria-label="AI Message Options"
                >
                    <i className="fas fa-ellipsis-v fa-sm"></i>
                </button>
                {showOptions && (
                    <div ref={optionsRef} className="absolute left-0 bottom-full mb-1 w-32 bg-white border border-border-default rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-left">
                        <button
                            onClick={handleCopyText}
                            className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"
                        >
                            {copied ? <CheckMarkIconSVG className="w-4 h-4 mr-1.5" /> : <NewCopyIconSVG className="w-4 h-4 mr-1.5 fill-current" />}
                            <span>{copied ? "Copied!" : "Copy"}</span>
                        </button>
                        <button
                            onClick={handleDelete}
                            className="w-full text-left px-2.5 py-1.5 text-xs text-red-600 hover:bg-red-500/10 rounded-md flex items-center space-x-1.5 transition-colors"
                        >
                            <i className="fas fa-trash-alt fa-fw mr-1.5"></i>
                            <span>Delete</span>
                        </button>
                    </div>
                )}
            </div>
        );
      };


      const ChatMessageItem = ({ 
        message, 
        onDeleteAiMessagePair,
        selectedUserMessageId, 
        onSelectUserMessage 
      }) => { 
        const isUser = message.role === 'user'; 
        const isError = message.isError === true; 
        const contentRef = useRef(null); 
        const [userCopied, setUserCopied] = useState(false);
        
        const isNonErrorAiMessageCard = message.role === 'model' && !isError;
        const messageLineAnimationClasses = isNonErrorAiMessageCard ? '' : 'animate-fade-in-up opacity-0';
        const messageLineAnimationStyles = isNonErrorAiMessageCard ? {} : { animationFillMode: 'forwards' };
        
        useEffect(() => {
          if (message.role === 'model' && !isError && !message.isLoading && (message.text || message.parts?.[0]?.text) && contentRef.current) {
            const preElements = contentRef.current.querySelectorAll('pre');
            preElements.forEach(preEl => {
              if (preEl.parentNode && preEl.parentNode.classList.contains('code-block-wrapper')) {
                 const codeElement = preEl.querySelector('code');
                 if(codeElement && !codeElement.dataset.highlighted){
                    hljs.highlightElement(codeElement);
                    codeElement.dataset.highlighted = 'true';
                 }
                return; 
              }
              
              const codeElement = preEl.querySelector('code');
              if (!codeElement) return;

              const wrapper = document.createElement('div');
              wrapper.classList.add('code-block-wrapper');
              wrapper.style.position = 'relative';

              let button = preEl.querySelector('.code-copy-button');
              if (!button) { 
                button = document.createElement('button');
                button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`; 
                button.classList.add(
                  'code-copy-button', 'absolute', 'p-1.5',
                  'bg-gray-100', 'hover:bg-gray-200',
                  'text-gray-600', 'hover:text-gray-800',
                  'border', 'border-gray-300', 'rounded-md',
                  'transition-colors', 'duration-150',
                  'opacity-80', 'hover:opacity-100'
                );
                button.style.top = '0.35rem';
                button.style.right = '0.35rem';
                button.style.zIndex = '10';
                button.setAttribute('aria-label', 'Copy code');
                
                button.onclick = () => {
                  if (codeElement) {
                    navigator.clipboard.writeText(codeElement.textContent || '').then(() => {
                      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"></path></svg>`; 
                      button.classList.add('text-green-500');
                      button.classList.remove('text-gray-600', 'hover:text-gray-800');
                      setTimeout(() => {
                        button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`;
                        button.classList.remove('text-green-500');
                        button.classList.add('text-gray-600', 'hover:text-gray-800');
                      }, 2000);
                    }).catch(err => console.error('Failed to copy: ', err));
                  }
                };
                 if (preEl.parentNode) {
                    preEl.parentNode.insertBefore(wrapper, preEl);
                    wrapper.appendChild(preEl); 
                    wrapper.appendChild(button); 
                }
              }
              
              if (!codeElement.dataset.highlighted) {
                hljs.highlightElement(codeElement);
                codeElement.dataset.highlighted = 'true';
              }
            });
          }
        }, [message.text, message.parts, message.role, message.isLoading, isError]);


        const handleCopyUserText = (textToCopy) => {
            navigator.clipboard.writeText(textToCopy).then(() => {
                setUserCopied(true);
                setTimeout(() => setUserCopied(false), 1500);
            }).catch(err => console.error('Failed to copy text: ', err));
        };


        if (message.role === 'system') { 
            const systemText = message.text || (message.parts?.[0]?.text || "");
            const systemMessageStyle = isError ? "px-4 py-2 text-xs text-red-700 bg-red-100 border border-red-300 rounded-full shadow-sm italic" : "px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic"; 
            return (<div className="flex justify-center my-4 animate-fade-in-up opacity-0" style={{animationFillMode: 'forwards'}}><div className={systemMessageStyle}>{isError ? <><i className="fas fa-exclamation-triangle mr-1.5"></i> {systemText}</> : systemText }</div></div>);
        }
        
        let bubbleBaseClasses = 'px-4 py-3 md:px-4 md:py-3 shadow-card relative group'; 
        let bubbleRoleClasses = ''; 
        let bubbleWidthClasses = ''; 
        let contentToShow = null;
        
        const messageTextContent = message.parts && message.parts[0] && typeof message.parts[0].text === 'string' ? message.parts[0].text : (message.text || "");

        if (isUser) { 
          bubbleRoleClasses = 'bg-surface-user-bubble-bg text-text-primary rounded-xl rounded-br-md';
          bubbleWidthClasses = 'max-w-[80%] sm:max-w-[75%]'; 
          const userFilesToDisplay = message.attachedFiles || (message.uiOnlyAttachedFiles || []);

          contentToShow = (
            <>
              {userFilesToDisplay && userFilesToDisplay.length > 0 && (
                <div className={`grid gap-1 ${messageTextContent ? 'mb-1.5' : ''} ${userFilesToDisplay.filter(f => f.type?.startsWith('image/')).length > 1 ? 'grid-cols-2 sm:grid-cols-3' : 'grid-cols-1'}`}>
                  {userFilesToDisplay.map((file, index) => {
                    if (file.type?.startsWith('image/') && file.apiData?.data && file.apiData?.mimeType) { 
                      const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`;
                      return (
                        <div key={file.id || file.name + index} className="rounded-lg overflow-hidden group relative max-w-full w-full">
                          <img src={imageSrc} alt={file.name || 'image preview'} className="block w-full max-h-60 object-contain rounded-lg" />
                        </div>
                      );
                    } else if (file.type?.startsWith('text/')) {
                      return ( 
                        <div key={file.id || file.name + index} className="bg-brand-primary/10 border border-brand-primary/20 p-2 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow-sm my-1">
                           <FileTextIcon className="text-brand-primary text-sm" />
                          <span className="truncate max-w-[120px] sm:max-w-[150px] text-text-primary font-medium">
                            {file.name}
                          </span>
                        </div>
                      );
                    }
                    return null;
                  })}
                </div>
              )}
              {messageTextContent && <p className="text-sm font-normal whitespace-pre-wrap break-words font-serif">{messageTextContent}</p>}
            </>
          );

        } else if (message.role === 'model') { 
            bubbleRoleClasses = `bg-surface-bubble-ai text-text-primary rounded-xl rounded-bl-md border border-gray-200 font-source-sans-pro`; // Changed bg-white to bg-surface-bubble-ai and border-[#E5E8EB] to border-gray-200
            bubbleWidthClasses = 'max-w-full w-full'; 
            
            if(isError) { 
                bubbleRoleClasses = `bg-red-50 border border-red-300 text-red-700 rounded-xl rounded-bl-md font-source-sans-pro`; 
                contentToShow = ( <div className="text-sm break-words"> <div className="flex items-center mb-1"><i className="fas fa-exclamation-triangle text-red-500 mr-2"></i><strong className="font-semibold">Error</strong></div>{messageTextContent.replace(/^Error:\s*/, '')} </div>); 
            } else { 
                contentToShow = (
                  <div ref={contentRef}>
                    <div className={`markdown-content break-words`} dangerouslySetInnerHTML={{ __html: marked.parse(messageTextContent || '') }} />
                  </div>
                );
            } 
        }

        return (
          <div className={`flex items-start ${isUser ? 'justify-end' : 'justify-start'} ${messageLineAnimationClasses} mb-1`} style={messageLineAnimationStyles}>
            <div 
                className={`${bubbleBaseClasses} ${bubbleWidthClasses} ${bubbleRoleClasses}`}
                onClick={isUser ? () => onSelectUserMessage(message.id === selectedUserMessageId ? null : message.id) : undefined}
            >
              {contentToShow} 

              {isUser && selectedUserMessageId === message.id && messageTextContent && (
                <button
                    onClick={(e) => { e.stopPropagation(); handleCopyUserText(messageTextContent); }}
                    className="absolute -bottom-3 -right-1 p-1.5 bg-gray-100 text-gray-600 border border-gray-300 rounded-full shadow-md hover:bg-gray-200 transition-all"
                    aria-label="Copy user message"
                >
                   {userCopied ? <CheckMarkIconSVG className="w-4 h-4" /> : <NewCopyIconSVG className="w-4 h-4 fill-current" />}
                </button>
              )}
            </div>
          </div>);
      };
      
       const ModelSelector = ({ models, selectedModelId, onSelectModel, isLoading, isAiCurrentlyProcessing }) => {
        const [isOpen, setIsOpen] = useState(false);
        const dropdownRef = useRef(null);
        const selectedModel = models.find(m => m.id === selectedModelId) || models[0];

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
                    setIsOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, []);

        const isDisabled = isLoading || isAiCurrentlyProcessing; // currentUser check removed

        return (
            <div className="relative" ref={dropdownRef}>
                <button
                    type="button"
                    onClick={() => setIsOpen(prev => !prev)}
                    className={`flex items-center justify-center text-[11px] font-medium text-text-secondary hover:text-brand-primary bg-surface-input hover:bg-interactive-hover/70 px-2 py-1 rounded-md border border-gray-300 transition-colors duration-150 focus:outline-none whitespace-nowrap ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                    disabled={isDisabled}
                >
                    <span>{selectedModel.uiName}</span>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={`w-3 h-3 ml-1 transform transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`}>
                        <path fillRule="evenodd" d="M5.22 8.22a.75.75 0 011.06 0L10 11.94l3.72-3.72a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.22 9.28a.75.75 0 010-1.06z" clipRule="evenodd" />
                    </svg>
                </button>
                {isOpen && (
                    <div className="absolute bottom-full right-0 mb-1.5 w-32 bg-white border border-border-default rounded-md shadow-xl z-30 p-1 animate-scale-in-subtle origin-bottom-right">
                        {models.map(model => (
                            <button
                                key={model.id}
                                onClick={() => {
                                    onSelectModel(model.id);
                                    setIsOpen(false);
                                }}
                                className={`w-full text-left px-2.5 py-1.5 text-xs rounded-md truncate transition-colors ${
                                    model.id === selectedModelId 
                                    ? 'bg-brand-primary/20 text-brand-primary font-medium' 
                                    : 'text-text-secondary hover:bg-interactive-hover/70'
                                }`}
                            >
                                {model.uiName}
                            </button>
                        ))}
                    </div>
                )}
            </div>
        );
    };

      const ChatInterface = ({ 
        messages, 
        onSendMessage, 
        isLoading, // This is isChatLoading from App
        onStopGeneration, 
        onRegenerateLastTextMessage, 
        onNewChat, 
        setChatError,
        currentChatId, 
        // onToggleSidebarRequest, // Sidebar removed
        // currentUser, // currentUser is always guest-like now
        onDeleteAiMessagePair, 
        selectedUserMessageId, 
        setSelectedUserMessageId,
        selectedModelId, 
        onSelectModel 
      }) => {
        const [inputText, setInputText] = useState('');
        const [selectedFiles, setSelectedFiles] = useState([]); 
        const [userHasScrolledUp, setUserHasScrolledUp] = useState(false);
        const [isWebSearchEnabledState, setIsWebSearchEnabledState] = useState(false); 

        const fileInputRef = useRef(null);
        const messagesEndRef = useRef(null);
        const chatContainerRef = useRef(null);
        const contentEditableRef = useRef(null);

        useEffect(() => { 
            const container = chatContainerRef.current; if (!container) return; 
            const handleScroll = () => { const { scrollTop, scrollHeight, clientHeight } = container; setUserHasScrolledUp(scrollHeight - scrollTop - clientHeight >= 20);}; 
            container.addEventListener('scroll', handleScroll, { passive: true }); 
            
            const handleClickOutsideMessages = (event) => {
              if (chatContainerRef.current && !event.target.closest('.group') && !event.target.closest('.ai-message-options-trigger')) { 
                setSelectedUserMessageId(null);
              }
            };
            document.addEventListener('click', handleClickOutsideMessages);

            return () => {
              container.removeEventListener('scroll', handleScroll);
              document.removeEventListener('click', handleClickOutsideMessages);
            };
        }, [setSelectedUserMessageId]); 
        
        useEffect(() => {
          const lastMessage = messages[messages.length - 1];
          const messagesEndEl = messagesEndRef.current;
          if (!messagesEndEl) return;

          const isLastItemIndicator = lastMessage && lastMessage.role === 'model' && lastMessage.isLoading && !(lastMessage.text || lastMessage.parts?.[0]?.text);
          
          if (lastMessage && (lastMessage.role === 'user' || isLastItemIndicator || (lastMessage.role === 'system' && lastMessage.id === 'loading_chat'))) {
            messagesEndEl.scrollIntoView({ behavior: (isLastItemIndicator || lastMessage.id === 'loading_chat') ? "auto" : "smooth" });
          } else if (lastMessage && lastMessage.role === 'model' && !userHasScrolledUp) {
             messagesEndEl.scrollIntoView({ behavior: lastMessage.isLoading ? "auto" : "smooth" });
          }
        }, [messages, userHasScrolledUp]);

        useEffect(() => { 
            if (contentEditableRef.current) {
                contentEditableRef.current.style.height = 'auto';
                const maxHeight = parseInt(getComputedStyle(contentEditableRef.current).maxHeight, 10);
                let newHeight = contentEditableRef.current.scrollHeight;
                if (maxHeight && newHeight > maxHeight) {
                    newHeight = maxHeight;
                }
                contentEditableRef.current.style.height = `${newHeight}px`;
            }
        }, [inputText, selectedFiles]); 

        const handleFileChange = async (event) => { const files = Array.from(event.target.files); processAndSetFiles(files); if (fileInputRef.current) fileInputRef.current.value = ""; };
        
        const handlePaste = async (event) => {
            const pastedText = event.clipboardData.getData('text/plain');
            const pastedFiles = Array.from(event.clipboardData.files);

            if (pastedFiles.length > 0) {
                event.preventDefault();
                await processAndSetFiles(pastedFiles, true);
            } else if (pastedText && contentEditableRef.current && document.activeElement === contentEditableRef.current) {
                event.preventDefault();
                document.execCommand('insertText', false, pastedText);
                setInputText(contentEditableRef.current.innerText); 
            }
        };

        const processAndSetFiles = async (filesArray, isFromPaste = false) => { if (!filesArray.length) return false; let filesToProcess = []; let currentTotalSize = selectedFiles.reduce((acc, curr) => acc + (curr.file?.size || 0), 0); let didProcessAnyFile = false; let localErrorMessage = null; for (const file of filesArray) { const isImage = file.type.startsWith('image/'); const isTxt = file.type === 'text/plain' || (file.name && file.name.toLowerCase().endsWith('.txt')); if (!isImage && !isTxt) { if (isFromPaste) console.log(`Pasted unsupported file: ${file.name} (${file.type})`); else localErrorMessage = `File "${file.name}" (type: ${file.type}) is not supported. Only images and .txt files are allowed.`; continue; } if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { localErrorMessage = `File "${file.name}" is larger than ${MAX_FILE_SIZE_MB}MB.`; continue; } if (currentTotalSize + file.size > MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024) { localErrorMessage = `Total file size cannot exceed ${MAX_TOTAL_FILES_SIZE_MB}MB.`; break; } filesToProcess.push(file); currentTotalSize += file.size; didProcessAnyFile = true; } if(localErrorMessage){ setChatError(localErrorMessage); } else { setChatError(null); } if (filesToProcess.length > 0) { const processedFileObjects = await Promise.all( filesToProcess.map(async (file) => { const id = Date.now().toString(36) + Math.random().toString(36).substring(2) + file.name; let apiData; if (file.type.startsWith('image/')) { const base64Data = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onloadend = () => resolve(reader.result.split(',')[1]); reader.onerror = (error) => reject(error); }); apiData = { mimeType: file.type, data: base64Data }; } else { const textContent = await file.text(); apiData = { textContent: textContent }; } return { id, file, name: file.name, type: file.type, apiData }; }) ); setSelectedFiles(prev => [...prev, ...processedFileObjects.filter(f => f)]); } return didProcessAnyFile; };
        
        const removeSelectedFile = (fileId) => { setSelectedFiles(prev => prev.filter(f => f.id !== fileId)); };

        const handleInputFromContentEditable = () => {
             setInputText(contentEditableRef.current?.innerText || ''); 
        };
        
        const handleSubmit = (e) => { 
            if(e) e.preventDefault(); 
            // currentUser check removed (always guest)
            
            const currentText = contentEditableRef.current?.innerText.trim() || '';
            if (!currentText && selectedFiles.length === 0) return; 
            setUserHasScrolledUp(false); 
            setChatError(null); 
            onSendMessage(currentText, selectedFiles, isWebSearchEnabledState); 
            if(contentEditableRef.current) contentEditableRef.current.innerText = '';
            setInputText(''); 
            setSelectedFiles([]); 
        };

        const handleContentEditableKeyDown = (e) => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
                const isLikelyDesktop = window.innerWidth > 768; 
                if (isLikelyDesktop) { 
                    e.preventDefault();
                    if (!isSendButtonActuallyDisabled) { 
                        handleSubmit(e); 
                    }
                }
            }
        };

        const isAiCurrentlyProcessing = messages.some(m => m.role === 'model' && m.isLoading && !m.isError);
        const currentInputTextFromEditable = contentEditableRef.current?.innerText?.trim() || '';
        const isSendButtonActuallyDisabled = (!isAiCurrentlyProcessing && (isLoading || (currentInputTextFromEditable === '' && selectedFiles.length === 0))); // currentUser check removed
        
        const handleToggleWebSearch = (newValue) => {
            if (!(isLoading || isAiCurrentlyProcessing)) {
                setIsWebSearchEnabledState(newValue);
            }
        };
        
        const sendOrStopButtonBaseClasses = "w-8 h-8 flex items-center justify-center font-semibold rounded-full transition-all duration-150 ease-in-out transform active:animate-button-press focus:outline-none";
        let sendOrStopButtonDynamicClasses = "";

        if (isAiCurrentlyProcessing) { 
            sendOrStopButtonDynamicClasses = "bg-slate-500 hover:bg-slate-600 text-white"; 
        } else if (isSendButtonActuallyDisabled) { 
            sendOrStopButtonDynamicClasses = "bg-brand-send-active opacity-60 text-white cursor-not-allowed"; 
        } else { 
            sendOrStopButtonDynamicClasses = "bg-brand-send-active hover:bg-brand-send-hover text-white focus:ring-2 focus:ring-offset-1 focus:ring-brand-send-active/50";
        }
        
        useEffect(() => { 
          if (contentEditableRef.current) {
            contentEditableRef.current.innerText = ''; 
          }
          setInputText('');
          setSelectedFiles([]);
          setIsWebSearchEnabledState(false); 
        }, [currentChatId]); // currentUser dependency removed

        const activeMessages = messages.filter(m => (m.role !== 'system' || m.isError) && m.id !== 'loading_chat_indicator');


        return (
          <div className="w-full h-full flex flex-col bg-white md:rounded-xl shadow-chat-window overflow-hidden">
            <header className="p-3 flex items-center justify-between flex-shrink-0 bg-white border-b border-border-light shadow-header">
                {/* Hamburger icon removed */}
                <h1 className="text-xl font-sans font-semibold text-gray-800 text-left flex-grow">AlphaGPT</h1>
                <button
                    onClick={() => {
                        onNewChat();
                        setSelectedUserMessageId(null);
                    }}
                    className="p-1.5 text-text-secondary hover:text-brand-primary rounded-full hover:bg-interactive-hover/70 transition-colors focus:outline-none"
                    aria-label="New Chat"
                    disabled={isLoading || isAiCurrentlyProcessing}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6">
                        <path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zM12.75 9a.75.75 0 00-1.5 0v2.25H9a.75.75 0 000 1.5h2.25V15a.75.75 0 001.5 0v-2.25H15a.75.75 0 000-1.5h-2.25V9z" clipRule="evenodd" />
                    </svg>
                </button>
            </header>
            
            <div ref={chatContainerRef} className="flex-grow p-4 md:p-5 space-y-3 md:space-y-4 overflow-y-auto chat-messages-container relative bg-surface-chat-area">
                { /* Login prompt removed */ }
                { activeMessages.length === 0 && !isLoading ? ( 
                    <div className="absolute inset-0 flex flex-col items-center justify-center text-center pointer-events-none p-8 animate-fade-in-up opacity-0" style={{animationDelay: '0.2s', animationFillMode: 'forwards'}}>
                        <NewEmptyStateIconSVG className="w-16 h-16 mb-5 text-brand-send-active" />
                        <p className="text-2xl lg:text-3xl font-serif text-gray-800 leading-tight">
                            How can I help you<br />today?
                        </p>
                         {currentChatId && <p className="text-xs text-text-subtle mt-3">Send a message to get started in this chat.</p>}
                    </div> 
                ) : null }

                {messages.map((msg, idx) => { 
                    const isThisMessageAiAndFinalized = msg.role === 'model' && !msg.isLoading && !msg.isError && (msg.parts?.[0]?.text || msg.text);
                    let canThisAiMessageBeRegenerated = false;
                    if(isThisMessageAiAndFinalized) {
                        let userPromptIndex = -1;
                        for(let i = idx - 1; i >= 0; i--) {
                            if (messages[i].role === 'user') {
                                let interveningUserMessageBetweenThisAiAndItsUserPrompt = false;
                                for (let j = i + 1; j < idx; j++) {
                                     if (messages[j].role === 'user') {
                                        interveningUserMessageBetweenThisAiAndItsUserPrompt = true;
                                        break;
                                    }
                                }
                                if (!interveningUserMessageBetweenThisAiAndItsUserPrompt) {
                                    userPromptIndex = i;
                                    break;
                                }
                            }
                        }
                        canThisAiMessageBeRegenerated = userPromptIndex !== -1;
                    }

                    return (
                        <React.Fragment key={msg.id}>
                            {((msg.role === 'user' && ( (msg.parts && msg.parts[0]?.text) || msg.text || msg.attachedFiles?.length > 0 || msg.uiOnlyAttachedFiles?.length > 0)) ||
                             (msg.role === 'model' && (!msg.isLoading || (msg.isLoading && (msg.text || msg.parts?.[0]?.text )))) || 
                             msg.role === 'system' ||
                             msg.isError) && (
                                <div> 
                                    <ChatMessageItem 
                                        message={msg} 
                                        onDeleteAiMessagePair={onDeleteAiMessagePair}
                                        selectedUserMessageId={selectedUserMessageId}
                                        onSelectUserMessage={setSelectedUserMessageId}
                                    /> 
                                </div>
                            )}
                            {msg.role === 'model' && msg.isLoading && !(msg.text || msg.parts?.[0]?.text) && !msg.isError && ( 
                                <ThinkingAnimation isPotentiallySearching={msg.searchUsed && msg.loadingText === "Searching..."} />
                            )}

                            {isThisMessageAiAndFinalized && (
                                <div className={`flex items-center space-x-2 mt-1 ml-0 justify-start mb-2`}> 
                                    {canThisAiMessageBeRegenerated && (
                                        <button 
                                            onClick={() => { 
                                                setChatError(null); 
                                                onRegenerateLastTextMessage(msg.id, isWebSearchEnabledState);
                                                setSelectedUserMessageId(null);
                                            }} 
                                            className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 group focus:outline-none focus:ring-1 focus:ring-brand-primary/50"
                                            aria-label="Regenerate response" 
                                            disabled={isLoading || isAiCurrentlyProcessing} 
                                        > 
                                            <NewRefreshIcon className="w-5 h-5 transition-transform duration-200" />
                                        </button> 
                                    )}
                                      <ChatMessageItemOptions 
                                        message={msg} 
                                        onDeleteAiMessagePair={onDeleteAiMessagePair} 
                                      />
                                </div>
                            )}
                        </React.Fragment>
                    )
                })}
                <div ref={messagesEndRef} className="h-1" />
            </div>
            
            <form onSubmit={handleSubmit} className="bg-surface-chat-area flex-shrink-0">
              <div className="p-2 md:p-3">
                <div
                    className="flex flex-col bg-white border border-gray-200 rounded-xl p-2.5 shadow-sm focus-within:border-gray-300 focus-within:shadow-input-active-glow transition-all duration-150"
                    onClick={(e) => {
                        if (contentEditableRef.current && // currentUser check removed
                            !contentEditableRef.current.contains(e.target) && 
                            e.target.tagName !== 'BUTTON' && 
                            !e.target.closest('button') &&
                           !e.target.closest('[aria-label="Attach file"]') && 
                           !e.target.closest('[aria-label="Toggle Web Search"]') &&
                           !e.target.closest('.relative') 
                           ) {
                           contentEditableRef.current.focus();
                        }
                    }}
                >
                  {selectedFiles.some(f => f.type.startsWith('image/')) && (
                    <div className="image-preview-container-input">
                        {selectedFiles.filter(f => f.type.startsWith('image/')).map(file => (
                        <div key={file.id} className="relative w-14 h-14 rounded-md overflow-hidden shadow-sm group border border-gray-200">
                            <img
                            src={`data:${file.apiData.mimeType};base64,${file.apiData.data}`}
                            alt={file.name}
                            className="w-full h-full object-cover"
                            />
                            <button
                                type="button"
                                onClick={() => removeSelectedFile(file.id)}
                                className="absolute top-0.5 right-0.5 w-5 h-5 bg-black/50 hover:bg-black/70 text-white rounded-full flex items-center justify-center transition-opacity focus:outline-none opacity-100"
                                aria-label="Remove image"
                            >
                                <NewCloseIconSVG className="w-3 h-3"/>
                            </button>
                        </div>
                        ))}
                    </div>
                  )}
                  {selectedFiles.some(f => !f.type.startsWith('image/')) && (
                    <div className={`file-pill-container ${selectedFiles.some(f => f.type.startsWith('image/')) ? 'mt-1.5' : ''}`}>
                        {selectedFiles.filter(f => !f.type.startsWith('image/')).map(file => (
                        <div key={file.id} className="file-pill">
                            <FileTextIcon className="file-pill-icon"/>
                            <span className="file-pill-name">{file.name}</span>
                            <button type="button" onClick={() => removeSelectedFile(file.id)} className="file-pill-remove">
                                <i className="fas fa-times"></i>
                            </button>
                        </div>
                        ))}
                    </div>
                  )}

                  <div
                    ref={contentEditableRef}
                    contentEditable={!(isLoading || isAiCurrentlyProcessing)}  // currentUser check removed
                    onInput={handleInputFromContentEditable}
                    onPaste={handlePaste}
                    onKeyDown={handleContentEditableKeyDown}
                    data-placeholder={"Ask AlphaGPT..."} // currentUser check removed for placeholder
                    className={`content-editable-input w-full flex-1 text-sm md:text-[15px] focus:outline-none resize-none overflow-y-auto relative`} // cursor-not-allowed removed
                    style={{ maxHeight: '100px', minHeight: '40px' }}
                    suppressContentEditableWarning={true}
                  >
                  </div>

                  <div className="flex justify-between items-end w-full pt-2.5 mt-auto">
                    <div className="flex items-center">
                        <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" multiple accept="image/*,.txt,text/plain" disabled={isLoading || isAiCurrentlyProcessing} /> {/* currentUser check removed */}
                        
                        <button
                          type="button"
                          onClick={() => fileInputRef.current?.click()}
                          className="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-gray-700 rounded-full hover:bg-gray-200/70 border border-gray-300 transition-colors duration-150 disabled:opacity-50 flex-shrink-0 focus:outline-none"
                          aria-label="Attach file"
                          disabled={isLoading || isAiCurrentlyProcessing} // currentUser check removed
                        >
                          <PlusIcon />
                        </button>
                        
                        <button
                          type="button"
                          onClick={() => handleToggleWebSearch(!isWebSearchEnabledState)}
                          className={`w-8 h-8 flex items-center justify-center rounded-full border transition-colors duration-150 disabled:opacity-50 flex-shrink-0 focus:outline-none ml-1.5
                            ${isWebSearchEnabledState
                              ? 'bg-blue-500/10 border-blue-500/30 text-blue-500 hover:bg-blue-500/20' 
                              : 'border-gray-300 text-gray-500 hover:text-gray-700 hover:bg-gray-200/70' 
                            }
                          `}
                          aria-label="Toggle Web Search"
                          aria-pressed={isWebSearchEnabledState}
                          disabled={isLoading || isAiCurrentlyProcessing} // currentUser check removed
                        >
                          <GlobeIcon className="w-4 h-4" />
                        </button>

                    </div>
                    <div className="flex items-end space-x-2"> 
                        <ModelSelector
                            models={AVAILABLE_MODELS}
                            selectedModelId={selectedModelId}
                            onSelectModel={onSelectModel}
                            // currentUser removed
                            isLoading={isLoading}
                            isAiCurrentlyProcessing={isAiCurrentlyProcessing}
                        />
                        <button
                            type={isAiCurrentlyProcessing ? "button" : "submit"}
                            onClick={isAiCurrentlyProcessing ? onStopGeneration : undefined }
                            disabled={isSendButtonActuallyDisabled}
                            className={`${sendOrStopButtonBaseClasses} ${sendOrStopButtonDynamicClasses}`}
                            style={{ overflow: 'hidden' }} 
                            aria-label={isAiCurrentlyProcessing ? "Stop generation" : "Send message"}
                        >
                        {isAiCurrentlyProcessing ? (
                            <i className="fas fa-stop text-sm"></i>
                        ) : (
                            <UpArrowSendIcon />
                        )}
                        </button>
                    </div>
                  </div>
                </div>
              </div>
            </form>
          </div>);
      };

      // AuthPage Component Removed
      
      const App = () => { 
        // currentUser is now effectively a guest, always present
        const [currentUser, setCurrentUser] = useState({ uid: 'guest_user', email: 'Guest User' }); // Mock user
        // authLoading is false as there's no Firebase auth
        const [authLoading, setAuthLoading] = useState(false);
        
        const [chatMessages, setChatMessages] = useState([]); 
        const [isChatLoading, setIsChatLoading] = useState(false); 
        const [chatError, setChatError] = useState(null); 
        const [currentChatId, setCurrentChatId] = useState('session_chat_init'); // Initial chat ID for the session
        
        // chatHistoryList is not used as sidebar is removed, but kept for structure if local history is added later
        const [chatHistoryList, setChatHistoryList] = useState([]); 
        
        // Sidebar and PIN related states removed
        
        const [selectedUserMessageId, setSelectedUserMessageId] = useState(null);
        const [selectedModelId, setSelectedModelId] = useState(DEFAULT_MODEL_ID);


        // initialLoadDoneRef removed as it was for Firebase chat history loading
        const isStoppingGenerationRef = useRef(false);
        const streamTextBuffer = useRef("");
        const streamSourcesBuffer = useRef([]); 
        
        // Firebase Auth useEffect removed

        // Firebase PIN loading useEffect removed

        // saveUserPin function removed

        useEffect(() => { 
            if (chatError) { 
                const errorId = Date.now() + '_sys_validation_err'; 
                const newErrorMsg = {id: errorId, role: 'system', text: chatError, isError: true, timestamp: new Date().getTime()};
                setChatMessages(prev => { 
                    const lastMessage = prev[prev.length -1]; 
                    if(lastMessage && lastMessage.id.includes('_sys_validation_err') && lastMessage.text === chatError) return prev; 
                    return [...prev, newErrorMsg]; 
                }); 
            }
        }, [chatError]); 

        // Firebase Chat History loading useEffect removed

        // Firebase Message loading useEffect removed for currentChatId (messages are now local)


        const handleNewChat = useCallback(() => {
            // No Firebase interaction for new chat
            const newSessionId = 'session_chat_' + Date.now().toString(36) + Math.random().toString(36).substring(2);
            setCurrentChatId(newSessionId); 
            setChatMessages([]);      
            setChatError(null);
            // setIsSidebarActuallyOpen(false); // Sidebar removed
            return newSessionId; // Return new ID for consistency if needed by caller
          }, []); 
        

        const getGeminiHistory = (currentMessagesFromState) => { 
            const geminiMessages = currentMessagesFromState
                .filter(msg => !(msg.role === 'system' || (msg.role === 'model' && msg.isLoading && !(msg.parts?.[0]?.text || msg.text) ) || msg.isError))
                .map(msg => {
                    let partsForGemini = [];
                    if (msg.parts && Array.isArray(msg.parts)) { 
                        partsForGemini = [...msg.parts];
                    } else if (msg.text) { 
                        partsForGemini = [{text: msg.text}];
                    }
                    
                    // Handling uiOnlyAttachedFiles (from input) or attachedFiles (from "DB", now local state)
                    const filesToConsider = msg.uiOnlyAttachedFiles || msg.attachedFiles || [];

                    filesToConsider.forEach(file => {
                        if (file.type.startsWith('image/') && file.apiData?.mimeType && file.apiData?.data) {
                            partsForGemini.push({ inlineData: file.apiData });
                        } else if ((file.name?.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent) {
                            const fileContentMarker = `\n[Content of attached file: ${file.name}]\n`;
                            if (!partsForGemini.some(p => p.text && p.text.includes(fileContentMarker))) {
                               partsForGemini.push({ text: `${fileContentMarker}${file.apiData.textContent}\n[End of file: ${file.name}]\n` });
                            }
                        }
                    });
                    return { role: msg.role, parts: partsForGemini }; 
                }).filter(entry => entry.parts && entry.parts.length > 0 && entry.parts.some(p => (p.text && p.text.trim()) || p.inlineData ));

            if (geminiMessages.length > 0 && geminiMessages[0].role === 'model') {
                const firstUserIndex = geminiMessages.findIndex(m => m.role === 'user');
                if (firstUserIndex === -1) return []; 
                const slicedHistory = geminiMessages.slice(firstUserIndex);
                if (slicedHistory.length > 1 && slicedHistory[0].role === slicedHistory[1].role) {
                    return [slicedHistory[0]]; 
                }
                return slicedHistory;
            }
            return geminiMessages;
        };


        useEffect(() => { if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") { setChatError("Gemini API Key is not configured."); } }, []); 
        
        const handleStopGeneration = useCallback(() => {
            isStoppingGenerationRef.current = true;
            setIsChatLoading(false); 

            setChatMessages(prevMessages => {
                return prevMessages.map(msg => {
                    if (msg.role === 'model' && msg.isLoading) {
                        let newText = streamTextBuffer.current || (msg.parts?.[0]?.text || msg.text) || ""; 
                        const stopNotice = "*Generation stopped by user.*";
                        
                        if (!newText && !(msg.parts?.[0]?.text || msg.text)){ 
                            newText = stopNotice;
                        } else if (newText && !newText.includes(stopNotice)) {
                            const currentContent = newText;
                            if (currentContent.trim()) {
                                let processedContent = currentContent;
                                const isInCodeBlock = (processedContent.match(/```/g) || []).length % 2 !== 0;
                                if (isInCodeBlock) {
                                    processedContent += "\n```"; 
                                }
                                newText = processedContent + (processedContent.trim() ? "\n\n---\n" : "") + stopNotice;
                            } else {
                                newText = stopNotice;
                            }
                        } else if (!newText && (msg.parts?.[0]?.text || msg.text) && !(msg.parts?.[0]?.text || msg.text).includes(stopNotice)){ 
                             newText = (msg.parts?.[0]?.text || msg.text) + ((msg.parts?.[0]?.text || msg.text).trim() ? "\n\n---\n" : "") + stopNotice;
                        }
                        
                        return { ...msg, parts: [{text: newText}], text: newText, isLoading: false, sources: streamSourcesBuffer.current.length > 0 ? [...streamSourcesBuffer.current] : msg.sources };
                    }
                    return msg;
                });
            });
        }, []); 
        
        // handleDeleteChat removed as no persistent chat history

        const mergeCitations = (existingSources, newSources) => {
            if (!newSources || newSources.length === 0) return existingSources;
            const existingUris = new Set((existingSources || []).map(s => s.uri));
            const uniqueNewSources = newSources.filter(src => src.uri && !existingUris.has(src.uri));
            return [...(existingSources || []), ...uniqueNewSources];
        };

        const addMessageToLocalChat = async (role, text, filesForDisplay, aiSpecificData = {}) => {
            const messageId = Date.now().toString(36) + Math.random().toString(36).substring(2);
            const messagePartsForDisplay = [];
            if (text) messagePartsForDisplay.push({ text: text });

            // uiOnlyAttachedFiles for user messages, filesForDisplay from input are already structured for this
            const attachedFilesForLocalState = filesForDisplay.map(f => ({
                id: f.id,
                name: f.name,
                type: f.type,
                apiData: f.apiData // This holds base64 for images, textContent for text files
            }));
            
            const messageData = {
              id: messageId,
              role: role,
              parts: messagePartsForDisplay.length > 0 ? messagePartsForDisplay : [{text: ""}], 
              text: text || "", // For easier access sometimes, though parts is canonical
              timestamp: new Date().getTime(),
              ...(role === 'user' && attachedFilesForLocalState.length > 0 && { uiOnlyAttachedFiles: attachedFilesForLocalState }), 
              ...(role === 'model' && aiSpecificData.sources && { sources: aiSpecificData.sources }),
              ...(role === 'model' && aiSpecificData.searchUsed !== undefined && { searchUsed: aiSpecificData.searchUsed }),
              ...(role === 'model' && aiSpecificData.modelUsed && { modelUsed: aiSpecificData.modelUsed }), 
            };
            
            setChatMessages(prev => [...prev, messageData]);
            return messageId; 
        };

        const updateMessageInLocalChat = async (messageKey, text, aiSpecificData = {}) => {
             setChatMessages(prev => prev.map(msg => {
                if (msg.id === messageKey) {
                    return {
                        ...msg,
                        parts: text ? [{ text: text }] : [{text: ""}],
                        text: text || "",
                        timestamp: new Date().getTime(), 
                        isLoading: aiSpecificData.isLoading !== undefined ? aiSpecificData.isLoading : msg.isLoading,
                        isError: aiSpecificData.isError !== undefined ? aiSpecificData.isError : msg.isError,
                        ...(aiSpecificData.sources !== undefined && { sources: aiSpecificData.sources }),
                        ...(aiSpecificData.searchUsed !== undefined && { searchUsed: aiSpecificData.searchUsed }),
                        ...(aiSpecificData.modelUsed !== undefined && { modelUsed: aiSpecificData.modelUsed }),
                    };
                }
                return msg;
            }));
            return messageKey;
        };
        
        const _streamAiResponse = async (
            originalPromptPartsForGemini, 
            targetAiMessageUiId, // This will be the ID of the placeholder AI message
            historyForGeminiInit, 
            useSearchForThisTurn,
            currentLoadingText,
            // chatIdForSaving, // Not needed for local state version
            isRegeneration = false,
            modelToUse 
        ) => {
            // currentUser check removed (always guest)
            setIsChatLoading(true);
            streamTextBuffer.current = "";
            streamSourcesBuffer.current = []; 
            
            if (isStoppingGenerationRef.current) { 
                setIsChatLoading(false);
                return;
            }

            // Update placeholder in local state
             if (!isRegeneration) { // For new message, placeholder is already added
                setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { 
                    ...m, 
                    isLoading: true, 
                    isError: false, 
                    searchUsed: useSearchForThisTurn,
                    loadingText: currentLoadingText, 
                    text: "", 
                    parts: [{text: ""}], 
                    sources: null, 
                    timestamp: new Date().getTime(),
                    modelUsed: modelToUse 
                } : m));
            } else { // For regeneration, update existing message to loading state
                 updateMessageInLocalChat(targetAiMessageUiId, "", {
                    isLoading: true, isError: false, searchUsed: useSearchForThisTurn, 
                    loadingText: currentLoadingText, sources: null, modelUsed: modelToUse
                });
            }


            const performUiUpdateWithText = (isLoading = true) => { 
                if (!isStoppingGenerationRef.current || !isLoading) { 
                    updateMessageInLocalChat(targetAiMessageUiId, streamTextBuffer.current, {
                        isLoading: isLoading,
                        isError: false,
                        sources: streamSourcesBuffer.current.length > 0 ? [...streamSourcesBuffer.current] : null,
                        searchUsed: useSearchForThisTurn,
                        loadingText: isLoading ? (firstChunkReceived ? "" : currentLoadingText) : "",
                        modelUsed: modelToUse
                    });
                }
            };

            let firstChunkReceived = false; 
            try {
                const modelConfig = { model: modelToUse, systemInstruction: getSystemInstruction() }; 
                if (useSearchForThisTurn) { 
                    modelConfig.tools = [{ googleSearch: {} }];
                }
                const chatModel = genAI.getGenerativeModel(modelConfig);
                const chatSession = chatModel.startChat({ history: historyForGeminiInit });
                
                if (isStoppingGenerationRef.current) {
                     setIsChatLoading(false);
                     return;
                }

                const result = await chatSession.sendMessageStream(originalPromptPartsForGemini);
                

                for await (const chunk of result.stream) { 
                    if (isStoppingGenerationRef.current) break;
                    if(!firstChunkReceived && chunk.text()?.trim()){ 
                         firstChunkReceived = true;
                    }
                    
                    const rawChunkText = chunk.text();
                    let chunkTextForDisplay = "";

                    if (typeof rawChunkText === 'string') {
                        const lines = rawChunkText.split('\n');
                        const filteredLines = lines.filter(line => 
                            !line.trim().startsWith("tool_code") &&
                            !line.trim().startsWith("print(google_search.search")
                        );
                        if (filteredLines.length > 0 && filteredLines.some(line => line.trim() !== "" || lines.length === filteredLines.length )) {
                           chunkTextForDisplay = filteredLines.join('\n');
                        } else if (filteredLines.length === 0 && rawChunkText.trim() !== "") {
                            chunkTextForDisplay = ""; 
                        } else {
                            chunkTextForDisplay = rawChunkText; 
                        }
                    }
                    
                    let sourcesDeltaProcessed = false;
                    if (chunk.candidates && chunk.candidates[0]?.groundingMetadata?.groundingChunks) {
                        const sourcesDelta = chunk.candidates[0].groundingMetadata.groundingChunks
                          .filter(gc => gc.web && gc.web.uri)
                          .map(gc => ({ uri: gc.web.uri, title: gc.web.title || gc.web.uri }));
                        if (sourcesDelta && sourcesDelta.length > 0) {
                           streamSourcesBuffer.current = mergeCitations(streamSourcesBuffer.current, sourcesDelta);
                           sourcesDeltaProcessed = true;
                        }
                    }

                    if (chunkTextForDisplay.length > 0) {
                        const textParts = chunkTextForDisplay.split(/(\s+|\*+|`+|_|~|---|===|\n)/);
                        for (const part of textParts) {
                            if (isStoppingGenerationRef.current) break;
                            if (part.length === 0) continue;
                            streamTextBuffer.current += part;
                            performUiUpdateWithText(); 
                            await new Promise(resolve => setTimeout(resolve, Math.min(60, Math.max(15, part.length * 10)))); 
                        }
                    } else if (sourcesDeltaProcessed) {
                        if(streamTextBuffer.current || firstChunkReceived) performUiUpdateWithText(); 
                    }
                    
                    if (isStoppingGenerationRef.current) break;
                }
                
                let finalText = streamTextBuffer.current;
                const stopNoticeStr = "*Generation stopped by user.*";
                if (isStoppingGenerationRef.current && !finalText.includes(stopNoticeStr)) {
                    const isInCodeBlock = (finalText.match(/```/g) || []).length % 2 !== 0;
                    if (isInCodeBlock) finalText += "\n```";
                    finalText += (finalText.trim() ? "\n\n---\n" : "") + stopNoticeStr;
                } else if (!isStoppingGenerationRef.current && !finalText.trim() && (!streamSourcesBuffer.current || streamSourcesBuffer.current.length === 0)) {
                    if (useSearchForThisTurn) { 
                        finalText = "I'm having a little trouble searching right now, or perhaps clear information isn't available on this topic. You could try regenerating the message, or ask your question a bit differently or more clearly. Thank you! 🙏";
                    } else {
                        finalText = "I think I had some trouble understanding. Could you please clarify your question? 🤔";
                    }
                } else if (!isStoppingGenerationRef.current && !finalText.trim() && streamSourcesBuffer.current && streamSourcesBuffer.current.length > 0) {
                     finalText = "*Content is based on search results.*";
                }
                streamTextBuffer.current = finalText;
                performUiUpdateWithText(false); // Final update, not loading

            } catch (err) {
                console.error("AI stream error in _streamAiResponse:", err);
                let errorTextForUser = "A technical difficulty occurred. Please try again."; 
                if (err.message?.toLowerCase().includes("api key not valid")) errorTextForUser = "It seems there's an issue with the API key.";
                else if (err.message?.toLowerCase().includes("candidate was blocked")) errorTextForUser = "I cannot provide this response due to safety policies.";
                else if (err.message?.toLowerCase().includes("quota")) errorTextForUser = "The API usage limit has been reached.";
                
                streamTextBuffer.current = errorTextForUser;
                updateMessageInLocalChat(targetAiMessageUiId, errorTextForUser, {
                    isLoading: false, isError: true, searchUsed: useSearchForThisTurn, loadingText: ""
                });
            } finally {
                setIsChatLoading(false);
            }
        };

        const handleSendChatMessage = useCallback(async (messageText, filesToSendFromInput, userWebSearchPreference) => {
            // currentUser check removed
            // activeChatId logic for new chat creation via handleNewChat removed, using currentChatId directly
            
            if (!messageText.trim() && filesToSendFromInput.length === 0) return;

            isStoppingGenerationRef.current = false; 
            setChatError(null);
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") {
                setChatError("Gemini API Key is not configured.");
                return;
            }
            
            const userMessageUiId = await addMessageToLocalChat('user', messageText, filesToSendFromInput);
            // No need to check userMessageDbId as it's local now

            const aiPlaceholderUiId = Date.now().toString() + '_model_resp_temp_ui';
            const needsSearch = userWebSearchPreference;
            const finalLoadingText = needsSearch ? "Searching..." : "Thinking...";
            
            const preliminaryAiPlaceholder = { 
                id: aiPlaceholderUiId, 
                role: 'model', 
                text: '', 
                parts: [{text:''}],
                loadingText: finalLoadingText, 
                timestamp: new Date().getTime(), 
                isLoading: true, 
                isError: false, 
                sources: null, 
                searchUsed: needsSearch,
                modelUsed: selectedModelId
            };

            setChatMessages(prev => {
                const cleanPrev = prev.filter(m => m.id !== 'loading_chat_indicator' && m.id !== 'error_loading_messages');
                return [...cleanPrev, preliminaryAiPlaceholder];
            });

            const currentUserMessagePartsForGemini = [];
            if (messageText.trim()) {
                currentUserMessagePartsForGemini.push({ text: messageText.trim() });
            }
            filesToSendFromInput.forEach(file => {
                if (file.type.startsWith('image/') && file.apiData.mimeType && file.apiData.data) {
                    currentUserMessagePartsForGemini.push({ inlineData: file.apiData });
                } else if ((file.name.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData.textContent) {
                    currentUserMessagePartsForGemini.push({ text: `\n[Content of attached file: ${file.name}]\n${file.apiData.textContent}\n[End of file: ${file.name}]\n` });
                }
            });
            
            // Get history from current chatMessages state, up to *before* the new user message and placeholder AI message
            const currentMessagesSnapshot = chatMessages.filter(m => m.id !== userMessageUiId && m.id !== aiPlaceholderUiId);
            const baseHistory = getGeminiHistory(currentMessagesSnapshot); 
            
            const userMessageObjectForHistory = {
                role: 'user',
                parts: currentUserMessagePartsForGemini 
            };
            const historyForGemini = [...baseHistory, userMessageObjectForHistory];

            if (currentUserMessagePartsForGemini.length > 0) {
                await _streamAiResponse(
                    currentUserMessagePartsForGemini, 
                    aiPlaceholderUiId, 
                    historyForGemini, 
                    needsSearch, 
                    finalLoadingText,
                    // currentChatId, // No longer needed for DB saving
                    false, // Not a regeneration
                    selectedModelId
                );
            } else { 
                 updateMessageInLocalChat(aiPlaceholderUiId, "No valid content to send.", {
                     isLoading: false, isError: true, loadingText: ""
                 });
                setIsChatLoading(false);
            }
            
        }, [chatMessages, currentChatId, selectedModelId]); // currentUser dependency removed, handleNewChat dependency removed


        const handleRegenerateLastTextMessage = useCallback(async (aiMessageIdToRegenerate, userWebSearchPreference) => { 
            // currentUser, currentChatId checks for existence removed (always guest, always a currentChatId)
            isStoppingGenerationRef.current = false; 
            setChatError(null);
            if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY") {
                setChatError("API Key is not configured for regeneration.");
                return;
            }

            const messagesForCurrentChat = [...chatMessages];
            let userPromptMsgForRegen = null;
            let historyUpToUserPrompt = [];
            
            let aiMsgIndex = messagesForCurrentChat.findIndex(m => m.id === aiMessageIdToRegenerate && m.role === 'model');
            if (aiMsgIndex === -1) {
                console.warn("Regen: AI message not found in current UI state. ID:", aiMessageIdToRegenerate);
                setChatError("Cannot regenerate: Original AI message not found.");
                return;
            }
            const modelUsedForOriginalResponse = messagesForCurrentChat[aiMsgIndex].modelUsed || selectedModelId;

            for (let i = aiMsgIndex - 1; i >= 0; i--) {
                if (messagesForCurrentChat[i].role === 'user') {
                    let interveningUserMessage = false;
                    for (let j = i + 1; j < aiMsgIndex; j++) {
                        if (messagesForCurrentChat[j].role === 'user') {
                            interveningUserMessage = true;
                            break;
                        }
                    }
                    if (!interveningUserMessage) {
                        userPromptMsgForRegen = messagesForCurrentChat[i];
                        historyUpToUserPrompt = getGeminiHistory(messagesForCurrentChat.slice(0, i)); 
                        break;
                    }
                }
            }
            
            if (!userPromptMsgForRegen) {
                console.warn("Regen: User prompt not found for AI msg. AI ID:", aiMessageIdToRegenerate);
                setChatError("Cannot regenerate: Original user prompt not found.");
                return;
            }
            
            const needsSearch = userWebSearchPreference;
            const finalLoadingText = needsSearch ? "Searching..." : "Thinking...";
            
            const promptPartsForRegen = [];
            // Reconstruct prompt parts from the user message object (which might have uiOnlyAttachedFiles or attachedFiles)
            if(userPromptMsgForRegen.parts && Array.isArray(userPromptMsgForRegen.parts)){
                promptPartsForRegen.push(...userPromptMsgForRegen.parts.filter(p => p.text || p.inlineData)); 
            } else if (userPromptMsgForRegen.text) { 
                 promptPartsForRegen.push({text: userPromptMsgForRegen.text});
            }
            
            const filesFromUserMessage = userPromptMsgForRegen.uiOnlyAttachedFiles || userPromptMsgForRegen.attachedFiles || [];
            filesFromUserMessage.forEach(fileMeta => {
                if(fileMeta.type?.startsWith('image/') && fileMeta.apiData) { 
                    if (!promptPartsForRegen.some(p => p.inlineData && p.inlineData.data === fileMeta.apiData.data)) { 
                       promptPartsForRegen.push({ inlineData: fileMeta.apiData });
                    }
                } else if ((fileMeta.name?.toLowerCase().endsWith('.txt') || fileMeta.type === 'text/plain') && fileMeta.apiData?.textContent) {
                     const fileContentMarker = `\n[Content of attached file: ${fileMeta.name}]\n`;
                     if (!promptPartsForRegen.some(p => p.text && p.text.includes(fileContentMarker))) {
                        promptPartsForRegen.push({ text: `${fileContentMarker}${fileMeta.apiData.textContent}\n[End of file: ${fileMeta.name}]\n` });
                     }
                }
            });


            if (promptPartsForRegen.length > 0) {
                await _streamAiResponse(
                    promptPartsForRegen, 
                    aiMessageIdToRegenerate, 
                    historyUpToUserPrompt, 
                    needsSearch, 
                    finalLoadingText,
                    // currentChatId, // Not needed for DB
                    true, // Is regeneration
                    modelUsedForOriginalResponse
                );
            } else { 
                 updateMessageInLocalChat(aiMessageIdToRegenerate, "No content found to regenerate.", {
                     isLoading: false, isError: true, loadingText:""
                 });
                setIsChatLoading(false);
            }
        }, [chatMessages, currentChatId, selectedModelId]); // currentUser dependency removed

        // handleRequestToggleSidebar, handleSubmitUnlockPin, handleLogout, handleSendPasswordReset removed

        const handleDeleteAiMessagePair = async (aiMessageId) => {
            // currentUser, currentChatId, database checks removed
    
            const currentMessages = [...chatMessages]; 
            const aiMessageIndex = currentMessages.findIndex(msg => msg.id === aiMessageId);
    
            if (aiMessageIndex === -1) {
                setChatError("Could not find the AI message to delete.");
                return;
            }
    
            let idsToDelete = [aiMessageId];
    
            if (aiMessageIndex > 0) {
                let precedingUserMessage = null;
                for (let i = aiMessageIndex - 1; i >= 0; i--) {
                    if (currentMessages[i].role === 'model') { 
                        break; 
                    }
                    if (currentMessages[i].role === 'user') {
                        let interveningUserMessage = false;
                        for (let k = i + 1; k < aiMessageIndex; k++) {
                            if (currentMessages[k].role === 'user') {
                                interveningUserMessage = true;
                                break;
                            }
                        }
                        if (!interveningUserMessage) {
                           precedingUserMessage = currentMessages[i];
                        }
                        break; 
                    }
                }
                if (precedingUserMessage) {
                    idsToDelete.push(precedingUserMessage.id);
                }
            }
    
            setChatMessages(prev => prev.filter(msg => !idsToDelete.includes(msg.id)));
            // DB deletion removed
        };


        if (authLoading) { // This will be false by default now
            return (
                <div className="h-full flex items-center justify-center bg-surface-main">
                    <div className="w-10 h-10 border-4 border-brand-primary border-t-transparent rounded-full animate-spin-continuous"></div>
                </div>
            );
        }
        
        // AuthPage and related modals removed from render path

        return (
            <div className="h-full text-text-primary flex font-sans bg-surface-main">
                {/* PIN Modals Removed */}
                {/* Sidebar Removed */}
                <div className="flex-grow h-full flex flex-col min-w-0"> 
                    <ChatInterface 
                        messages={chatMessages} 
                        onSendMessage={handleSendChatMessage} 
                        isLoading={isChatLoading} 
                        onStopGeneration={handleStopGeneration} 
                        onRegenerateLastTextMessage={handleRegenerateLastTextMessage} 
                        onNewChat={handleNewChat} 
                        setChatError={setChatError} 
                        currentChatId={currentChatId}
                        // onToggleSidebarRequest removed
                        // currentUser removed (passed implicitly by App structure)
                        onDeleteAiMessagePair={handleDeleteAiMessagePair}
                        selectedUserMessageId={selectedUserMessageId}
                        setSelectedUserMessageId={setSelectedUserMessageId}
                        selectedModelId={selectedModelId}
                        onSelectModel={setSelectedModelId}
                    />
                </div>
            </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
